#!/usr/bin/env python3
import argparse
description = """From an IMAS IDS create a move of the LCFS or
separatrixes.
"""


parser = argparse.ArgumentParser(description='Create EQDSK from IDS time slice')

parser.add_argument('-s', '--shot', metavar='SHOT', type=int,
                    help='Shot number',
                    required=True)
parser.add_argument('-r', '--run', metavar='RUN', type=int,
                    help='Run number', required=True)
parser.add_argument('-u', '--user', metavar='USER', type=str, default="public",
                    help='Username')
parser.add_argument('-d', '--device',
                    metavar="DEVICE", type=str, default="ITER", help='Device')
parser.add_argument('-ts', '--time_start', metavar='#time_start', type=float,
                    default=0.0, help='Starting time')
parser.add_argument('-te', '--time_end', type=float, default=999999)
parser.add_argument('-o', '--output_name', type=str, default="out.gif",
                    help="Name of gif.", metavar="OUTNAME")

# Additional cosmetic arguments
parser.add_argument('-minx', '--min_x', type=float, help="Abscissa lower limit",
                    metavar="MIN X")
parser.add_argument('-maxx', '--max_x', type=float, help="Abscissa upper limit",
                    metavar="MAX X")
parser.add_argument('-miny', '--min_y', type=float, help="Ordinate lower limit",
                    metavar="MIN Y")
parser.add_argument('-maxy', '--max_y', type=float, help="Ordinate upper limit",
                    metavar="MAX Y")

args = parser.parse_args()

import imas

#ids = imas.ids(args.shot, args.run)
#ids.open_env(args.user, args.device, '3')
ids = imas.DBEntry(backend_id=imas.imasdef.MDSPLUS_BACKEND,
    user_name=args.user, db_name=args.device, shot=args.shot, run=args.run,
    data_version='3')
ids.open()
# Old API
#wall_ids = ids.wall
#wall_ids.get()
wall_ids = ids.get("wall")

#summary_ids = ids.summary
#summary_ids.get()
summary_ids = ids.get("summary")

#equilibrium = ids.equilibrium

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from functools import partial

figure = plt.figure()
figure.set_tight_layout(True)
ax = figure.add_subplot()
ax.grid(True)
ax.axis('equal')
ax.set_xlabel('R [m]')
ax.set_ylabel('Z [m]')

wall_contour_r = wall_ids.description_2d[0].limiter.unit[0].outline.r
wall_contour_z = wall_ids.description_2d[0].limiter.unit[0].outline.z
Z_LIMITS = np.min(wall_contour_z) - 1, np.max(wall_contour_z) + 1
R_LIMITS = np.min(wall_contour_r) - 1, np.max(wall_contour_r) + 1

# Plot limiter
ax.plot(wall_contour_r, wall_contour_z, 'r-')
ax.set_title(f"S={args.shot} R={args.run} U={args.user} D={args.device}")
lines = [] # Holds plotting objects

N = len(summary_ids.time)
i = 0

# First separatrix or LCFS
lcfs_contour_r = []
lcfs_contour_z = []

# Optional secondary contour or LCFS
secondary_contour_r = []
secondary_contour_z = []

# Labels
times = []
from time import sleep
for time in summary_ids.time:

    if time < args.time_start:
        continue
    if time > args.time_end:
        continue

    times.append(f"t={time:12.4f}s")
    # equilibrium.getSlice(time, 1)
    equilibrium = ids.get_slice("equilibrium", time,
        imas.imasdef.CLOSEST_INTERP)

    slice = equilibrium.time_slice[0]
    if len(slice.boundary_separatrix.outline.r):
        collection_r = []
        collection_z = []
        # Figure out the parts of the plot.
        # When the contour is stored in this place, it is saved as one array.
        # Therefore the following way tries to find indexes where the different
        # parts of the contour start and end. Indexes are obtained by checking
        # for significant jump in radial *and* vertical direction. Sometimes
        # the contour makes a vertical jump but practically no radial move and
        # vice versa.
        diff_r = np.abs(np.diff(slice.boundary_separatrix.outline.r))
        indexes = [_ for _ in np.argwhere(diff_r > 0.5).flatten()]

        diff_z = np.abs(np.diff(slice.boundary_separatrix.outline.z))
        indexes += [_ for _ in np.argwhere(diff_z > 0.5).flatten()]
        indexes = [_ + 1 for _ in set(indexes)]
        indexes.sort()

        # Make chunks based on these changes
        prev_index = 0

        if len(indexes) == 0:
            collection_r.append(slice.boundary_separatrix.outline.r)
            collection_z.append(slice.boundary_separatrix.outline.z)
        else:
            for index in indexes:
                collection_r.append(slice.boundary_separatrix.outline.r[prev_index:index])
                collection_z.append(slice.boundary_separatrix.outline.z[prev_index:index])
                prev_index = index
            collection_r.append(slice.boundary_separatrix.outline.r[indexes[-1]:])
            collection_z.append(slice.boundary_separatrix.outline.z[indexes[-1]:])
        lcfs_contour_r.append(collection_r)
        lcfs_contour_z.append(collection_z)
    else:
        lcfs_contour_r.append([])
        lcfs_contour_z.append([])

    if len(slice.boundary_secondary_separatrix.outline.r):
        collection_r = []
        collection_z = []
        # Figure out the parts of the plot.
        diff_r = np.abs(np.diff(slice.boundary_secondary_separatrix.outline.r))
        indexes = [_ for _ in np.argwhere(diff_r > 0.5).flatten()]

        diff_z = np.abs(np.diff(slice.boundary_secondary_separatrix.outline.z))
        indexes += [_ for _ in np.argwhere(diff_z > 0.5).flatten()]
        indexes = [_ + 1 for _ in set(indexes)]
        indexes.sort()

        # Make chunks based on these changes
        prev_index = 0
        if len(indexes) == 0:
            collection_r.append(slice.boundary_secondary_separatrix.outline.r)
            collection_z.append(slice.boundary_secondary_separatrix.outline.z)
        else:
            for index in indexes:
                collection_r.append(slice.boundary_secondary_separatrix.outline.r[prev_index:index])
                collection_z.append(slice.boundary_secondary_separatrix.outline.z[prev_index:index])
                prev_index = index
            collection_r.append(slice.boundary_secondary_separatrix.outline.r[indexes[-1]:])
            collection_z.append(slice.boundary_secondary_separatrix.outline.z[indexes[-1]:])
        secondary_contour_r.append(collection_r)
        secondary_contour_z.append(collection_z)

    else:
        secondary_contour_r.append([])
        secondary_contour_z.append([])
N = len(times)
# Now make the animation

def update(i, lr, lz, sr, sz, lines, labels):
    while lines:
        el = lines.pop(0)
        el.remove()

    if len(lr[i]):
        for j in range(len(lr[i])):
            lines += ax.plot(lr[i][j], lz[i][j], '-', c='b')

    if len(sr[i]):
        for j in range(len(sr[i])):
            lines += ax.plot(sr[i][j], sz[i][j], '-', c='g')
    ax.set_ylim(Z_LIMITS)
    ax.set_xlim(R_LIMITS)

    lines.append(ax.text(0.7, 0.9, labels[i], transform = ax.transAxes))

frame_update = partial(update, lr=lcfs_contour_r, lz=lcfs_contour_z,
                              sr=secondary_contour_r, sz=secondary_contour_z,
                              lines=lines, labels=times)

anim = FuncAnimation(figure, frame_update, frames=N, interval=250)
anim.save(args.output_name, writer=PillowWriter())




