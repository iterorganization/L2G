#!/usr/bin/env python3
import L2G
L2G.addStreamHandler()
L2G.enableLogging()
L2G.log.info("Starting up...")
import time

import argparse

description = """Runs a L2G case, described within a L2G JSON file.
"""

parser = argparse.ArgumentParser(description=description)

parser.add_argument('-i', '--input', type=str,
                    required=True, help='Input Json file')
parser.add_argument('-v', '--verbose', help='Verbosity',
                    default=0, type=int)

parser.add_argument('-p', '--progress', help='Progress bar. Enable/Disable return carriage',
                    default=1, type=int)
parser.add_argument('-r', '--run_flt', help='Run FLT tracing',
                    default=1, type=int)
parser.add_argument('-fl', '--get_fls', help="Obtain fieldlines",
                    default=1, type=int)
parser.add_argument('-cd', '--calculate_drsep', help="Calculate drsep",
                    default=1, type=int)
args = parser.parse_args()

RETURN_CARRIAGE = "\r\t"
if not args.progress:
    RETURN_CARRIAGE = "\n\t"


import os
import sys
from pathlib import Path

# Check if the JSON file can be read.
json_input = args.input
if not os.access(json_input, mode=os.R_OK):
    L2G.log.info(f"Could not read: '{json_input}'!")
    sys.exit(-1)

# Now that everything went okay start with the module loads. Putting these
# module loads at the top of the file creates a time overhead.

import L2G
import L2G.utils
import L2G.meshio_utils
import L2G.elm
import L2G.hlm_profiles
import medcoupling as mc
import MEDLoader as ml
from L2G.core import PyEmbreeAccell
if args.verbose:
    L2G.addStreamHandler()
    L2G.enableLogging()
import glob
import numpy as np

# Load json file
inp = L2G.utils.load_l2g_json(json_input)

CUTOFF = 4.3e3
if "cutoff" in inp:
    CUTOFF = inp["cutoff"]

R_BREAK = 0.025
RAMP_DOWN_TRANSITION_IP = 10e6
# Create an instance of the FieldLineTracer so that we start setting parameters
# and input data.

OUTPUT_DIRECTORY = os.path.dirname(os.path.abspath(args.input))

if "output_directory" in inp:
    OUTPUT_DIRECTORY = os.path.abspath(inp["output_directory"])
    Path(OUTPUT_DIRECTORY).mkdir(parents=True, exist_ok=True)


time_start = time.perf_counter()
L2G.log.info("Loading data")

flt_case = L2G.utils.FieldLineTracer()
flt_case.name = inp['name']

elm_case = L2G.utils.FieldLineTracer()
elm_case.name = inp['name'] + "_elm"

# Load global parameters
L2G.utils.set_parameters_and_options(inp, flt_case)
L2G.utils.load_flt_settings(inp['flt'], flt_case)

if "elm" in inp:
    L2G.utils.set_parameters_and_options(inp, elm_case)
    L2G.utils.load_elm_settings(inp['elm'], elm_case)
    if "r_break" in inp['elm']:
        R_BREAK = inp['elm']['r_break']
if "ramp-down" in inp:
    if "Ip transition" in inp["ramp-down"]:
        RAMP_DOWN_TRANSITION_IP = inp["ramp-down"]["Ip transition"]


# Load parameters

# See if there are any FL ids to set
fl_ids = []
if "fl_ids" in inp:
    fl_ids = inp["fl_ids"]

# See if there is a custom wall limiter
if 'wall_limiter' in inp:
    custom_wall_limiter = True
    L2G.log.info("Custom wall limiter included")
else:
    custom_wall_limiter = False

# Let's see if we run in a HPC job. Currently only slurm based.
L2G.utils.check_if_in_slurm_job(flt_case, elm_case)

TIME_LOADING_CASE = time.perf_counter() - time_start
L2G.log.info(f"Loaded case in {TIME_LOADING_CASE} seconds.")

L2G.log.info("")

L2G.log.info(f"Loading {inp['eq_type']} equilibriums")

equilIter = L2G.utils.EquilibriumIterator()

correct_helicity = True
if "correct_helicity" in inp:
    correct_helicity = inp["correct_helicity"]

equilIter.correctHelicity(correct_helicity)
# Figure out what kind of equilibriums do we have
if inp['eq_type'] == "imas":
    equilIter.loadIMASEquilibriums(inp['imas'])
else:
    equilIter.loadEqdskEquilibriums(inp['eqdsk_files'])

# Create the result MED file. If needed. Otherwise read the MED mesh from the
# existing FLT med file.
run_flt = True
resultFileName = os.path.join(OUTPUT_DIRECTORY, flt_case.name + '.med')
if os.path.exists(resultFileName):
    L2G.log.info("Result file name already exists. No need to rerun full FLT")
    run_flt = False
    # time.sleep(10)
else:
    targetSourceMesh = mc.ReadMeshFromFile(inp["flt"]["target_mesh"])
    ml.WriteMesh(resultFileName, targetSourceMesh, True)

resultMesh = mc.ReadMeshFromFile(resultFileName)


TIME_RUNNING_CASES = 0

N = len(equilIter)
for index, associated_time, equilibrium in equilIter:
    time_start = time.perf_counter()
    L2G.log.info("")
    L2G.log.info(f"Getting results for {index + 1} of {N} equilibriums.")
    L2G.log.info(f"Time={associated_time}.")
    L2G.log.info("")

    # Get EQDSKIO

    if custom_wall_limiter:
        equilibrium.wall_contour_r = np.array(inp['wall_limiter']['r'])
        equilibrium.wall_contour_z = np.array(inp['wall_limiter']['z'])

    flt_case.setEquilibrium(equilibrium)

    # Apply parameters and load Equilibrium. This is done everytime
    flt_case.applyParameters()
    flt_case.loadEq()

    flt_case.processDataOnMesh()
    # Running FLT and saving FLT data on input mesh
    if run_flt:
        L2G.log.info("Running FLT...")
        flt_case.runFltOnMesh()

        L2G.log.info("Calculating drsep...")
        flt_case.calculateDrsep()

        flt_case.saveMeshResultsToExistingMed(mesh_med=resultMesh,
            output_med_file=resultFileName, iteration=index,
            associated_time=associated_time)

    # Running FLT to get FLs from selected ids.
    if args.get_fls and fl_ids:
        L2G.log.info("Getting FLs...")
        # Obtain FLs and output them into a file.
        if all(isinstance(x, list) for x in fl_ids):
            # We have a group of IDs.
            for j, subset in enumerate(fl_ids):
                flt_case.fl_ids = subset
                flt_case.getFL()
                flt_case.saveFlToVTK(os.path.join(OUTPUT_DIRECTORY, f"{flt_case.name}_{j}_{index}.vtk"))

        else:
            flt_case.fl_ids = fl_ids
            flt_case.getFL()
            flt_case.saveFlToVTK(os.path.join(OUTPUT_DIRECTORY, f"{flt_case.name}_{index}.vtk"))

    # Now check for other things.

    if "elm" in inp:
        elm_case.setEquilibrium(equilibrium)
        elm_case.applyParameters()
        elm_case.loadEq()
        # First we need the connection length data. Check if the data exists

        conlen_data_path = os.path.join(OUTPUT_DIRECTORY, elm_case.name + f"_conlen_{index}.dat")

        if os.path.exists(conlen_data_path):
            conlen_data = np.loadtxt(conlen_data_path)
        else:
            elm_case.obtainOwlConlenGraph()
            conlen_data = elm_case.owl_conlen_data
            np.savetxt(conlen_data_path, conlen_data)

        elm_qpar_path = os.path.join(OUTPUT_DIRECTORY, elm_case.name + f"_qpar_{index}.dat")

        if os.path.exists(elm_qpar_path):
            qelm_data = np.loadtxt(elm_qpar_path)
        else:
            qelm_data = L2G.elm.get_elm_data(conlen_data)
            np.savetxt(elm_qpar_path, qelm_data)

        # Now create the ELM profiles

        # Obtain the arrays from the FLT results
        drsep = L2G.meshio_utils.fieldToNumpy(resultFileName, "drsep", index) * 1e-3
        Bdot = np.abs(L2G.meshio_utils.fieldToNumpy(resultFileName, 'Bdot', index))
        BVec = L2G.meshio_utils.fieldToNumpy(resultFileName, "BVec", index)
        flux = L2G.meshio_utils.fieldToNumpy(resultFileName, "flux", index)
        conlen = L2G.meshio_utils.fieldToNumpy(resultFileName, "conlen", index)
        bfield_mag = np.linalg.norm(BVec, axis=1)
        elm_case.eq.evaluate()
        Rb, Z, Btotal, Bpm = elm_case.eq.getOWL_midplane()

        elm_data_r = qelm_data[0]
        elm_data_q = qelm_data[1] * 1e6

        expansion = bfield_mag / Btotal

        expansionField = L2G.meshio_utils.numpyArrayToField(
            arr=expansion,
            fieldName="Total flux expansion",
            mesh=resultMesh,
            iteration=index,
            associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(expansionField,
            resultFileName)

        interELM = L2G.hlm_profiles.inter_ELM(drsep, Rb, Btotal, Bpm, Rb=R_BREAK)
        elm = L2G.hlm_profiles.ELM(drsep, elm_data_r, elm_data_q)

        elm_par_field = L2G.meshio_utils.numpyArrayToField(
            arr=elm,
            fieldName="Parallel ELM",
            mesh=resultMesh,
            iteration=index,
            associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(elm_par_field,
            resultFileName)

        interElm_par_field = L2G.meshio_utils.numpyArrayToField(
            arr=interELM,
            fieldName="Parallel inter-ELM",
            mesh=resultMesh,
            iteration=index,
            associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(interElm_par_field,
            resultFileName)

        q_parallel = interELM + elm
        q_parallel_field = L2G.meshio_utils.numpyArrayToField(
            arr=q_parallel,
            fieldName="Parallel ELM + inter-ELM",
            mesh=resultMesh,
            iteration=index,
            associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(q_parallel_field,
            resultFileName)

        q_inc = (elm + interELM) * Bdot / Btotal # Bdot applies the incident angle and the total
                                  # flux expansion
        q_inc = np.where(conlen > CUTOFF, q_inc, 0)
        q_inc_field = L2G.meshio_utils.numpyArrayToField(
            arr=q_inc,
            fieldName="ELM + inter-ELM",
            mesh=resultMesh,
            iteration=index,
            associatedTime = associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(q_inc_field,
            resultFileName)

    if "ramp-down" in inp:
        a = equilibrium.a
        R = equilibrium.mag_axis_r
        Ip = equilibrium.Ip # NOT used as P_sol
        Psol = equilibrium.Psol
        Area = equilibrium.Area
        # Obtain the arrays from the FLT results
        drsep = L2G.meshio_utils.fieldToNumpy(resultFileName, "drsep", index) * 1e-3
        Bdot = np.abs(L2G.meshio_utils.fieldToNumpy(resultFileName, 'Bdot', index))
        BVec = L2G.meshio_utils.fieldToNumpy(resultFileName, "BVec", index)
        flux = L2G.meshio_utils.fieldToNumpy(resultFileName, "flux", index)
        conlen = L2G.meshio_utils.fieldToNumpy(resultFileName, "conlen", index)
        bfield_mag = np.linalg.norm(BVec, axis=1)
        flt_case.eq.evaluate()
        Rb, Z, Btotal, Bpm = flt_case.eq.getOWL_midplane()
        if Ip < RAMP_DOWN_TRANSITION_IP:
            # Lambda_q is in millimeters.
            lambda_q = L2G.hlm_profiles.decay_length_L_mode_diverted(a, R,
                Ip, Area)

            L2G.log.info(f'RAMP_DOWN: {index} {associated_time} {lambda_q} {Ip}')
            q_par = L2G.hlm_profiles.single_exponential_psol(drsep, Btotal,
                Bpm, Rb,lambda_q * 1e-3, Psol)
        else:
            lambda_q = 'NaN'
            q_par = np.zeros(drsep.shape)

        q_inc = q_par * Bdot / Btotal
        q_inc = np.where(conlen > CUTOFF, q_inc, 0)
        # Convert to field
        q_field = L2G.meshio_utils.numpyArrayToField(arr=q_inc,
            fieldName=f"q ramp-down",
            mesh=resultMesh,
            iteration=index, associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(q_field,
            resultFileName)

        q_field = L2G.meshio_utils.numpyArrayToField(arr=q_par,
            fieldName=f"qpar ramp-down",
            mesh=resultMesh,
            iteration=index, associatedTime=associated_time)
        L2G.meshio_utils.writeFieldToAlreadyExistingMesh(q_field,
            resultFileName)

    TIME_RUNNING_CASES += time.perf_counter() - time_start

L2G.log.info("Time summaries:")
L2G.log.info("\tLoading case:".rjust(25) + f"{TIME_LOADING_CASE:.2f} s")
L2G.log.info("\tRunning cases:".rjust(25) + f"{TIME_RUNNING_CASES:.2f} s")
L2G.log.info("")
L2G.log.info(f"Total: {TIME_LOADING_CASE + TIME_RUNNING_CASES:.2f}s")