#!/usr/bin/python

description = """
F.L.A.T. - Field Line Analysis Tool

is a program meant for running L2G FLT cases which are describe in configuration
files (YAML). The configuration file can have a multitude of YAML documents,
each with their own role. Either a description of input data for the target
shadowed geometry and with the shadowing geometry. Or a description of which
equilibrium data or finally describing what HLM to use on the FLT data.

This program reads that file and then the user can decide what to run, on what
geometry, using which equilibrium and using which HLM.
"""

import argparse

parser = argparse.ArgumentParser(description=description)

parser.add_argument("yaml_file", nargs="?", help="Path to YAML file.")

# Add argument subgroups.
command_description = """Tell the binary what to do. Available commands:
 - run: Run a FLT case with the provided options (Default)
 - print: Prints the list of components in the YAML document
"""
subparsers = parser.add_subparsers(dest='command', help=command_description)
run_subparser = subparsers.add_parser('run', help="Run FLT case")
run_subparser.add_argument('geometry', help='Name of input data of geometries to be used in the FLT case')
run_subparser.add_argument('equilibrium', help='Name of the equilibrium data to be used in the FLT case')
run_subparser.add_argument('hlm', nargs="?", help='Name of the HLM to apply on the FLT data. Optional')
run_subparser.add_argument('--out-dir', help="Specify output directory. Default CWD.", type=str)
run_subparser.add_argument('--rotational-misalignment',
    help="Activate rotational misalignment. By that it checks if it has the " +
         "necessary information in the geometry to run a FLT case with " +
         "rotational misalignment activated.", action='store_true', default=False)
run_subparser.add_argument('--longwave-misalignment',
    help="Activate longwave misalignment. By that it checks if the case file" +
         " has the necessary information (vectors and length) to run a FLT" +
         " case with the longwave misalignment.", action='store_true',
         default=False)

# The no graphics is in reverse as this is actually flag to creating the
# images.
run_subparser.add_argument('--no-graphics', help='Do not create pictures.', action="store_false",
                            default=True)
parser.add_argument('--debug', help="Activate debug prints",
                    action='store_true', default=False)
print_subparser = subparsers.add_parser('print', help="Print case descriptions")

edit_subparser = subparsers.add_parser('rotate', help="Edit YAML descriptions")

args = parser.parse_args()

import os
import sys

if args.yaml_file is None:
    print(f"Specify path to a YAML file! Exiting.")
    sys.exit(1)

if not os.access(args.yaml_file, os.F_OK):
    print(f"File {args.yaml_file} does not exist! Exiting.")
    sys.exit(1)
if not os.access(args.yaml_file, os.R_OK):
    print(f"File {args.yaml_file} is not readable! Exiting.")
    sys.exit(1)


# See if command is specified

# Load the YAML file
import l2g.workflow

print(f"Path to yaml configuration file: {os.path.abspath(args.yaml_file)}")
with open(args.yaml_file, 'r') as f:
    yaml_text = f.read()


import l2g
l2g.addStreamHandler()
l2g.enableLogging()
if args.debug:
    l2g.enableDebugging()
list_of_targets, list_of_equilibriums, list_of_hlms = l2g.workflow.load_yaml_configuration(yaml_text)

# Quickly done commands:
if args.command == "print":
    print("Geometries:")
    for _ in list_of_targets:
        print(f'    {_.data["name"]}')
    print("Equilibriums:")
    for _ in list_of_equilibriums:
        print(f'    {_.data["name"]}')
    print("HLMs:")
    for _ in list_of_hlms:
        print(f'    {_.data["name"]}')
    sys.exit(0)

if args.command == "run":
    output_directory = ""

    # See the environment variable, for instance for L2G_OUTPUT_DIRECTORY
    if "L2G_OUTPUT_DIRECTORY" in os.environ:
        output_directory = os.environ["L2G_OUTPUT_DIRECTORY"]

    if args.out_dir:
        output_directory = args.out_dir

    if output_directory == "":
        # Finally set it default to CWD, if it is still empty
        output_directory = os.getcwd()

    output_directory = os.path.abspath(output_directory)
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)
    else:
        if not os.path.isdir(output_directory):
            print(f"Path for output directory: {output_directory} is not a directory!")
            sys.exit(1)
    print(f"Output directory set to: {output_directory}")
    print("Preparing to run FLT for the following configuration:")
    print(f"Target geometry: {args.geometry}")
    print(f"Equilibrium: {args.equilibrium}")
    print(f"HLM: {args.hlm}")

    # Confirm that the named blocks are indeed in the YAML configuration.
    geo_obj = None
    equ_obj = None
    hlm_obj = None

    for _ in list_of_targets:
        if _.data["name"] == args.geometry:
            geo_obj = _

    for _ in list_of_equilibriums:
        if _.data["name"] == args.equilibrium:
            equ_obj = _

    if args.hlm is not None:
        for _ in list_of_hlms:
            if _.data["name"] == args.hlm:
                hlm_obj = _

    if geo_obj is None:
        print(f"Geometry {args.geometry} is not in the YAML file. Exiting!")
        sys.exit(1)

    if equ_obj is None:
        print(f"Equilibrium {args.equilibrium} is not in the YAML file. Exiting!")
        sys.exit(1)

    if args.hlm is not None and hlm_obj is None:
        print(f"HLM {args.hlm} is not in the YAML file. Exiting!")
        sys.exit(1)

    case = l2g.workflow.create_case(geo_obj, equ_obj, hlm_obj)
    case.create_graphics = args.no_graphics

    print("Configuring case for run.")
    case.prepare()

    print("Checking if output file contains already the FLT data.")
    case.see_if_results_exists(output_directory=output_directory)

    print("Creating output result file if necessary")
    case.create_result_file_if_necessary()

    print("Running case")
    case.main()

    # Check if we do a rotational misalignment
    if args.rotational_misalignment:
        print("Running with rotational misalignment. Checking if geometry has")
        print("information about the axes")
        rot_mis_dict = geo_obj.data["rotational_misalignment"]
        if not "vectors" in rot_mis_dict:
            print(f"No vectors entry in rotational_misalignment!")
            sys.exit(1)
        rotational_vectors = rot_mis_dict["vectors"]
        if not "angles" in rot_mis_dict:
            print(f"No angles entry in rotational_misalignment!")
            sys.exit(1)
        rotational_angles = rot_mis_dict["angles"]
        # Now that we have everything, we need to prepare the 7 cases.
        # First case is the normal case that you have, while the other 6 cases
        # are the rotational cases around it's axes.

        print("Now running for different rotations")

        # In total there should be 2 * Number of axes of rotations performed.
        N = len(rotational_vectors) // 2

        # Since we already generated the images, do not generate new images
        case.create_graphics = False
        orig_mesh = case.mesh_obj
        output_file_base_name = case.case_name
        import numpy as np
        for index in range(N):
            for angle in rotational_angles:
                for j in range(2):
                    # Iterate for each rotation. Twice.
                    p1 = np.array(rotational_vectors[index * 2])
                    p2 = np.array(rotational_vectors[index * 2 + 1])
                    angle = (2 * j - 1) * angle
                    print(f"Rotating for {angle} degrees")
                    # Change the name
                    output_file_name = f"{output_file_base_name}_rot{2*index+j}_{angle:.2f}_degree.med"
                    case.mesh_obj = orig_mesh.rotateMesh(p1, p2, angle)
                    # First we need to delete the old target mesh in the Embree
                    # object.

                    target_geom_id = -1
                    for pair in case.embree_shadow_geom_ids:
                        if pair[1] == geo_obj.data["target_mesh"]:
                            target_geom_id = pair[0]
                            case.embree_shadow_geom_ids.remove(pair)
                            break
                    if target_geom_id != -1:
                        print("Removing target mesh from embree (self-shadowing)")
                        print("In order to load the rotated mesh")
                        print(f"Geom ID removed {target_geom_id}")
                        case.flt_obj.embree_obj.deleteMesh(target_geom_id)
                    print("Now loading the rotated mesh into shadow")
                    points, cells = case.mesh_obj.getMeshData()
                    case.flt_obj.setTargetData(points, cells)
                    new_geom_id = case.flt_obj.embree_obj.commitMesh(
                        case.flt_obj.target_vertices * case.flt_obj.parameters.target_to_m,
                        case.flt_obj.target_triangles)
                    print(f"Geom_id of target mesh in self-shadowing is {new_geom_id}")
                    case.embree_shadow_geom_ids.append((new_geom_id, geo_obj.data["target_mesh"]))

                    # case.reset_flt_obj()
                    # case.load_target_mesh()
                    # case.load_shadow_meshes()
                    # case.set_flt_objs()

                    case.see_if_results_exists(output_directory=output_directory,
                        file_name=output_file_name)
                    # Change the case name, so that the HLM data and everythin else
                    # get's computed only once, but change the result file path.
                    case.result_file_path = os.path.join(output_directory, output_file_name)
                    case.case_name = output_file_base_name
                    case.create_result_file_if_necessary()
                    print("Running case")
                    case.main()
                    print("Done")

    if args.longwave_misalignment:
        # In this case we have to load the whole case again, with the meshes,
        # since we are moving *all* meshes along a vector.
        if "longwave_misalignment" not in geo_obj.data:
            print("No longwave_misalignment entry in yaml file! Stopping")
            sys.exit(1)

        lw_mis_dict = geo_obj.data["longwave_misalignment"]
        # Now get the vectors
        if "vectors" not in lw_mis_dict:
            print("No vectors entry in longwave_misalignment! Stopping")
            sys.exit(1)
        longwave_vectors = lw_mis_dict["vectors"]

        if "lengths" not in lw_mis_dict:
            print("No lengths entry in longwave_misalignment! Stopping")
            sys.exit(1)
        longwave_lengths = lw_mis_dict["lengths"]

        # Now we loop by vector and then by lengths
        import numpy as np
        output_file_base_name = case.case_name
        for i, lw_vector in enumerate(longwave_vectors):
            for lw_length in longwave_lengths:
                print("Running case for longwave misalignment with directional vector:")
                print(lw_vector)
                print(f"With the length: {lw_length} mm.")

                output_med_name = f"{output_file_base_name}_lw_{i}_{lw_length}_mm.med"
                # Create a new case!
                case = l2g.workflow.create_case(geo_obj, equ_obj, hlm_obj)
                case.create_graphics = False

                case.longwave_misalignment = True
                # Add the vector.
                case.longwave_vector = list(np.array(lw_vector) * lw_length)

                print("Configuring case for run for longwave misalignment.")
                case.prepare()

                print("Checking if output file contains already the FLT data.")
                case.see_if_results_exists(output_directory=output_directory,
                    file_name=output_med_name)
                # Change the case name, so that the HLM data and everythin else
                # get's computed only once, but change the result file path.
                case.result_file_path = os.path.join(output_directory, output_med_name)
                case.case_name = output_file_base_name
                case.create_result_file_if_necessary()

                print("Creating output result file if necessary")
                case.create_result_file_if_necessary()

                print("Running case")
                case.main()

        pass

    sys.exit(0)