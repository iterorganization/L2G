#!/usr/bin/env python3 -u
print("Starting up...")
import time

class MeasureTime(object):
    def __init__(self, msg: str = ''):
        self.msg = msg
        self.t = None

    def __enter__(self):
        print('')
        print(self.msg)
        self.t = time.perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.t = time.perf_counter() - self.t
        if exc_value:
            return False
        print(f"\tDone in {self.t:.2f} seconds.")
        print('')

import argparse

parser = argparse.ArgumentParser(description='Create EQDSK from IDS time slice')

parser.add_argument('-i', '--input', type=str,
                    required=True, metavar='Input Json file')
parser.add_argument('-v', '--verbose', metavar='Verbosity',
                    default=0, type=int)

parser.add_argument('-p', '--progress', metavar='Progress bar. Enable/Disable return carriage',
                    default=1, type=int)
parser.add_argument('-e', '--generate_eqdsks', metavar='Output eqdsks if IMAS is used',
                    default=0, type=int)
parser.add_argument('-r', '--run_flt', metavar='Run FLT tracing',
                    default=1, type=int)
args = parser.parse_args()

RETURN_CARRIAGE = "\r\t"
if not args.progress:
    RETURN_CARRIAGE = "\n\t"



import os
if args.generate_eqdsks:
    eqdskDir = os.path.join(os.getcwd(), 'EQDSKS')
    if not os.path.exists(eqdskDir):
        os.mkdir(eqdskDir)
import sys
json_input = args.input
if not os.access(json_input, mode=os.R_OK):
    print(f"Could not read: '{json_input}'!")
    sys.exit(-1)

import L2G
import L2G.geom_utils
import medcoupling as mc
import MEDLoader as ml
from L2G.core import PyEmbreeAccell
if args.verbose:
    L2G.enableLogging()
import json
import glob
import numpy as np

# Load json file
inp = {}
try:
    # Comments with // are not allowed in a json file, so first we filter
    # those out and remove empty lines.
    text = open(json_input, 'r').read().splitlines()
    no_comments_text = []
    for line in text:
        if line.lstrip().startswith('//'):
            continue
        if line.strip() == "":
            continue
        comment_index = line.find('//')
        if comment_index == -1:
            no_comments_text.append(line)
        else:
            no_comments_text.append(line[:comment_index])
    # print('\n'.join(no_comments_text))
    inp = json.loads('\n'.join(no_comments_text))
except Exception as e:
    print("Failed to read JSON file:")
    print(e)

# Create L2G case
case = L2G.FieldLineTracer()
case.name = inp["name"]

flip_psirz = False
with MeasureTime("Setting parameters and options") as t:
    if "eq_flip_psi" in inp:
        flip_psirz = inp["eq_flip_psi"]
    case.name = inp['name']
    # Set the parameters
    for parameter in inp['parameters']:
        if not hasattr(case.parameters, parameter):
            print(f"Illegal parameter: {parameter}. Ignored")
        else:
            setattr(case.parameters, parameter, inp['parameters'][parameter])

    # Set the options
    for option in inp['options']:
        if not hasattr(case.options, option):
            print(f"Illegal option: {option}. Ignored")
        else:
            setattr(case.options, option, inp['options'][option])

with MeasureTime("Loading shadowed mesh.") as t:
    # Load the target mesh
    if not os.access(inp["target_mesh"], os.R_OK):
        print(f"Failed to read target mesh {inp['target_mesh']}!")
        print("Check the validity of the path.")
        sys.exit(-1)
    print(f"\tLoading {inp['target_mesh']}")
    verticesTarget, trianglesTarget = L2G.geom_utils.readMesh(inp["target_mesh"])
    case.setTargetData(verticesTarget, trianglesTarget)

with MeasureTime("Loading shadowing meshes.") as t:
    # Create Embree
    embree = PyEmbreeAccell()

    # Use glob if it is necessary
    shadowMeshFiles = []

    # Gather the file names
    for fileName in inp["shadow_meshes"]:
        if '*' in fileName:
            shadowMeshFiles += glob.glob(fileName)
        else:
            shadowMeshFiles.append(fileName)

    # Exclude any meshes if exclude_meshes is inside
    if "exclude_meshes" in inp:
        mesh_to_remove = []
        # Since files are actual paths it is the easiest to just loop the list
        # and accumulate which meshes to remove
        for filePath in shadowMeshFiles:
            fileName = os.path.basename(filePath)
            if fileName in inp["exclude_meshes"]:
                mesh_to_remove.append(filePath)
        #
        for m in mesh_to_remove:
            shadowMeshFiles.remove(m)

    # Now load it
    c = 0
    N = len(shadowMeshFiles)
    if "include_target_in_shadow" in inp:
        if inp["include_target_in_shadow"]:
            print("\tLoading target mesh also to Embree")
            print("")
            # v, t comes from before block. Do not delete it!!!
            embree.commitMesh(verticesTarget * case.parameters.target_dim_mul,
                              trianglesTarget)
    print(f"Loading {N} meshes")
    for filePath in shadowMeshFiles:
        fileName = os.path.basename(filePath)
        sys.stdout.write(f"{RETURN_CARRIAGE}Loading {fileName}: {c / N:.2f}%!")
        v, t = L2G.geom_utils.readMesh(filePath)
        c+=100
        sys.stdout.write(f"{RETURN_CARRIAGE}Loaded {fileName}: {c / N:.2f}%!")
        embree.commitMesh(v * 1e-3, t)
    print('')
    case.setEmbreeObj(embree)

# Figure out what kind of equilibriums do we have
if inp['eq_type'] == "imas":

    import L2G.imas_utils

    shot = inp['imas']['shot']
    run = inp['imas']['run']

    if 'user' not in inp['imas']:
        user = 'public'
    else:
        user = inp['imas']['user']

    if 'device' not in inp['imas']:
        device = 'iter'
    else:
        device = inp['imas']['device']

    if 'version' not in inp['imas']:
        version = '3'
    else:
        version = inp['imas']['version']

    if "times" in inp['imas']:
        time_slices = inp['imas']['times']
    else:
        # Construct the time_slices
        n_steps = int((inp['imas']['time_end'] - inp['imas']['time_start']) / inp['imas']['time_step']) + 1
        time_slices = np.linspace(inp['imas']['time_start'],
                                  inp['imas']['time_end'],
                                  n_steps)
else:
    # In case of EQDSK we might have globs!
    eqdsk_files = []
    for file in inp['eqdsk_files']:
        eqdsk_files += glob.glob(file)

    eqdsk_files.sort()


resultMesh = mc.ReadMeshFromFile(inp["target_mesh"])
resultFileName = os.path.join(os.path.dirname(os.path.abspath(args.input)),
                case.name + '.med')

if os.path.exists(resultFileName):
    print("Warning result file already exists! Overwriting!")
    # time.sleep(10)

ml.WriteMesh(resultFileName, resultMesh, True)

# Get the number of cases to run
if inp['eq_type'] == "imas":
    N = len(time_slices)
elif inp['eq_type'] == "eqdsk":
    N = len(eqdsk_files)

def numpyArrayToField(arr, fieldName, mesh, associatedTime, iteration,
        infoOnComponent=None):
    """Converts a numpy array to field. Currently the arrays in the L2G results
    are all 1D, even for 3D vectors. Therefore this function checks the size
    of these arrays to check if it is a multiple of number of cells.

    infoOnComponent are basically labels for multi component arrays, i.e.,

     * BVec is a magnetic field vector written in X, Y, Z (Cartesion).
     * baryCent is the barycenter of the triangles in cylindrical (R, Z, Phi)
       system
    """
    # Get shape for Array component! Meaning if it is a vector then the array
    # needs to know that

    # Find out how many values per cells there are
    N_cells = mesh.getNumberOfCells()
    ratio = int(len(arr) / N_cells)
    if ratio > 1:
        # Usually the ratio is either 1 for 1D arrays. But in case we have
        # vector fields (which are still written as 1D array in the L2G
        # library) we need to reshape it correctly, otherwise we will have
        # seemingly random values written in the MED file.
        arr = arr.reshape((N_cells, ratio))

    mcArray = ml.DataArrayDouble(np.asarray(arr, dtype=np.float))
    if infoOnComponent is not None:
        mcArray.setInfoOnComponents(infoOnComponent)

    field = ml.MEDCouplingFieldDouble.New(ml.ON_CELLS, ml.ONE_TIME)
    field.setMesh(mesh)
    field.setTime(associatedTime, iteration, -1)
    field.setTimeUnit("s")
    field.setName(fieldName)
    field.setArray(mcArray)
    return field

def writeFieldToAlreadyExistingMesh(field, meshName):
    fMEDFile=ml.MEDFileField1TS.New()
    fMEDFile.setFieldNoProfileSBT(field)
    fMEDFile.write(meshName,0)
    # ml.WriteFieldUsingAlreadyWrittenMesh(meshName, field)

# Now doing the main thing
_c = 0 # In case of EQDSK, the associated time
for i in range(N):
    with MeasureTime(f'Running case {i+1} out of {N}.') as f:
        # Get EQDSKIO
        if inp['eq_type'] == 'imas':
            # Get IMAS data
            case.eqdskio = L2G.imas_utils.imas2eqdsk(shot, run, time_slices[i],
                user, device, version)

            if flip_psirz:
                psirz = np.asarray(case.eqdskio.getPSIRZ())
                psirz *= -1
                case.eqdskio.setPSIRZ(psirz)
            case.eq.setEqdsk(case.eqdskio)
            associated_time = time_slices[i]
            if args.generate_eqdsks:
                with open(os.path.join(eqdskDir,case.eqdskio.getName()), 'w') as f:
                    f.write(case.eqdskio.generateText())
        else:
            # Read the EQDSK file
            case.loadEqdsk(eqdsk_files[i])
            if flip_psirz:
                psirz = np.asarray(case.eqdskio.getPSIRZ())
                psirz *= -1
                case.eqdskio.setPSIRZ(psirz)
                case.eq.setEqdsk(case.eqdskio)
            associated_time = _c
            _c += 1

        if args.run_flt:
            case.applyParameters()
            case.loadEq()

            case.processDataOnMesh()
            case.runFltOnMesh()

            # Write fields to mesh result
            for key in case.mesh_results.__dict__:
                print(f'\t\tWriting array "{key}"')
                array = case.mesh_results.__dict__[key]
                if array is None:
                    continue


                if key == "angle":
                    # Transform the angle
                    array = np.rad2deg(array)
                    array = np.where(array > 90.0, array - 90.0, 90.0 - array)

                if key in ["drsep", "conlen"]:
                    # Scale to mm from m
                    array *= 1000

                infoOnComponent = None
                if key == 'BVec':
                    # Write the Magnetic field vector properly. That is it is a
                    # 3 component array in Cartesian!
                    infoOnComponent = ['x', 'y', 'z']
                elif key == 'BVecCyln':
                    # Write the Magnetic field poloidal and toroidal component
                    # properly. A 2 component array in Cylindrical
                    infoOnComponent = ['Pol', 'Tor']
                elif key == 'baryCent':
                    # Again, write the baryCent properly. In this case the
                    # infoOnComponent will basically tell the user that the vector
                    # is in Cylindrical system.
                    infoOnComponent=['r', 'z', 'phi']

                field = numpyArrayToField(arr=array, fieldName=key,
                        mesh=resultMesh, associatedTime=associated_time,
                        iteration=i, infoOnComponent=infoOnComponent)

                writeFieldToAlreadyExistingMesh(field, resultFileName)
