#!/usr/bin/env python3

import argparse
description="""Utility for plotting the characteristic boundary contours of
poloidal magnetic fluxes.
"""
parser = argparse.ArgumentParser(description=description)
subparsers = parser.add_subparsers(dest="input_type",
    help="Data source: IMAS, EQDSK, ...", required=True)

imas_subparser = subparsers.add_parser("imas", help="Plot from IMAS source")
imas_subparser.add_argument('-s', '--shot', metavar='SHOT', type=int,
                    help='Shot number', default=135011, required=False)
imas_subparser.add_argument('-r', '--run', metavar='RUN', type=int, default=7,
                    help='Run number', required=False)
imas_subparser.add_argument('-u', '--user', metavar='USER', type=str, default="public",
                    help='Username')
imas_subparser.add_argument('-d', '--device',
                    metavar="DEVICE", type=str, default="ITER", help='Device')
imas_subparser.add_argument('-t', '--times', metavar='TIMES', type=float,
                    default=[11,25,35,65], nargs="*", help='Times to plot')

eqdsk_subparser = subparsers.add_parser("eqdsk", help="Plot from EQDSK source")
eqdsk_subparser.add_argument("-f", "--files", type=str,
                              nargs="*", help="Path to EQDSK file.")
eqdsk_subparser.add_argument("-t", "--times", type=float, nargs="*",
                             help="Time labels")
args = parser.parse_args()

import l2g.equil

iter_obj = l2g.equil.EquilibriumIterator()

if args.input_type == "imas":
    d = {
        "shot": args.shot,
        "run": args.run,
        "user": args.user,
        "device": args.device,
        "times": args.times
    }

    title=f"s={args.shot} r={args.run}"
    iter_obj.loadIMASEquilibriums(d)

elif args.input_type == "eqdsk":
    files = list(args.files)
    title=""
    iter_obj.loadEqdskEquilibriums(files)

    if args.times:
        if len(iter_obj) != len(args.times):
            print("Provide the same number of time labels as there are equilibriums!")
        iter_obj._times = args.times

import matplotlib.pyplot as plt
import matplotlib.axis
import matplotlib.cm
import numpy as np

def get_rjet_cycler(n: int) -> "matplotlib.colors.LinearSegmentedColormap":
    return plt.cycler("color", matplotlib.cm.gist_rainbow(np.linspace(0, 1, n)))

def get_rjet_colors(n: int) -> list[np.ndarray]:
    return [_["color"] for _ in get_rjet_cycler(n)]

def clean_path(paths, poly: "Polygon"):
    out_path = []
    for path in paths[0]:
        x_points = path[0]
        y_points = path[1]

        new_x = []
        new_y = []

        for i in range(len(x_points)):
            x = x_points[i]
            y = y_points[i]
            if poly.checkIfIn(x, y):
                new_x.append(x)
                new_y.append(y)
        out_path.append((new_x, new_y))
    return out_path, paths[1]

import l2g.equil
import l2g.external.equilibrium_analysis
from l2g.plot._marching_squares import Marching, plot_paths
from l2g.plot._polygon import Polygon

figure = plt.figure(figsize=(600/100, 800/100), dpi=100)
ax: matplotlib.axis.Axis = figure.add_subplot(111)

ax.grid(True)
ax.axis("equal")
ax.set_xlabel('R [m]')
ax.set_ylabel('Z [m]')
ax.set_facecolor('gainsboro')

WALL_R = iter_obj._equilibriums[0].wall_contour_r
WALL_Z = iter_obj._equilibriums[0].wall_contour_z

# Plot wall
ax.plot(WALL_R, WALL_Z, 'k-', linewidth=2.0)

marching_obj = Marching()
polygon = Polygon(WALL_R, WALL_Z)

# Get LCFSs
ax.set_title(title)

colors = get_rjet_colors(len(iter_obj))

for index, time, equilibrium in iter_obj:

    eq = l2g.external.equilibrium_analysis.EQA(equilibrium)
    eq.evaluate()
    marching_obj.setData(equilibrium.grid_r, equilibrium.grid_z,
                         equilibrium.psi)

    # Plot the boundary magnetic flux
    paths = marching_obj.getContourPath(eq.getBoundaryFluxValue())
    # Cleaning path
    paths = clean_path(paths, polygon)

    if int(time) == time:
        label = f"{int(time)}"
    else:
        label = f"{time:.3f}"

    plot_paths(ax, paths, label=label, color=colors[index])

ax.legend(title="Time [s]")
ax.axis("equal")

plt.show()
