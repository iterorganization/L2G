#!/usr/bin/env python3
import argparse
description = """From an IMAS IDS create a movie of the LCFS or
separatrixes.
"""


parser = argparse.ArgumentParser(description=description)

parser.add_argument('-s', '--shot', metavar='SHOT', type=int,
                    help='Shot number',
                    required=True)
parser.add_argument('-r', '--run', metavar='RUN', type=int,
                    help='Run number', required=True)
parser.add_argument('-u', '--user', metavar='USER', type=str, default="public",
                    help='Username')
parser.add_argument('-d', '--device',
                    metavar="DEVICE", type=str, default="ITER", help='Device')
parser.add_argument('-ts', '--time_start', metavar='#time_start', type=float,
                    default=0.0, help='Starting time')
parser.add_argument('-te', '--time_end', type=float, default=999999)
parser.add_argument('-o', '--output_name', type=str, default="out.gif",
                    help="Name of gif.", metavar="OUTNAME")

# Additional cosmetic arguments
parser.add_argument('-minx', '--min_x', type=float, help="Abscissa lower limit",
                    metavar="MIN X")
parser.add_argument('-maxx', '--max_x', type=float, help="Abscissa upper limit",
                    metavar="MAX X")
parser.add_argument('-miny', '--min_y', type=float, help="Ordinate lower limit",
                    metavar="MIN Y")
parser.add_argument('-maxy', '--max_y', type=float, help="Ordinate upper limit",
                    metavar="MAX Y")
parser.add_argument("-ns", '--number_of_samples', type=int,
                    metavar="#number_of_samples", default=100,
                    help="Number of samples to take. If the " +
                    "number of time slices in the IMAS IDS is lower than this" +
                    " then it is ignored.")

args = parser.parse_args()

import imas

#ids = imas.ids(args.shot, args.run)
#ids.open_env(args.user, args.device, '3')
ids = imas.DBEntry(backend_id=imas.imasdef.MDSPLUS_BACKEND,
    user_name=args.user, db_name=args.device, shot=args.shot, run=args.run,
    data_version='3')
ids.open()
# Old API
#wall_ids = ids.wall
#wall_ids.get()
wall_ids = ids.get("wall")

#summary_ids = ids.summary
#summary_ids.get()
summary_ids = ids.get("summary")

#equilibrium = ids.equilibrium

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from functools import partial

figure = plt.figure()
figure.set_tight_layout(True)
ax = figure.add_subplot()
ax.grid(True)
ax.axis('equal')
ax.set_xlabel('R [m]')
ax.set_ylabel('Z [m]')

try:
    wall_contour_r = wall_ids.description_2d[0].limiter.unit[0].outline.r
    wall_contour_z = wall_ids.description_2d[0].limiter.unit[0].outline.z
except:
    import l2g.equil
    wall_backup = l2g.equil.getBackUpIMASWallIds()

    wall_contour_r = np.concatenate([wall_backup.description_2d[0].limiter.unit[0].outline.r,
                             wall_backup.description_2d[0].limiter.unit[1].outline.r[::-1]])
    wall_contour_z = np.concatenate([wall_backup.description_2d[0].limiter.unit[0].outline.z,
                             wall_backup.description_2d[0].limiter.unit[1].outline.z[::-1]])

Z_LIMITS = np.min(wall_contour_z) - 1, np.max(wall_contour_z) + 1
R_LIMITS = np.min(wall_contour_r) - 1, np.max(wall_contour_r) + 1

# Plot limiter
ax.plot(wall_contour_r, wall_contour_z, 'r-')
ax.set_title(f"S={args.shot} R={args.run} U={args.user} D={args.device}")

N = len(summary_ids.time)

TIME_START = max(args.time_start, summary_ids.time[0])
TIME_END = min(args.time_end, summary_ids.time[-1])

# Check how many time slices are in the summar_ids
number_of_time_slices = np.sum(np.logical_and(summary_ids.time >= TIME_START,
                                              summary_ids.time <= TIME_END))
number_of_samples = args.number_of_samples

i = 0

# Labels
times = []
import l2g
l2g.enableDebugging()
l2g.addStreamHandler()
import l2g.equil
import l2g.external.equilibrium_analysis
import l2g.plot

it = l2g.equil.EquilibriumIterator()

if number_of_time_slices <= number_of_samples:
    dictionary = {
        "user": args.user,
        "shot": args.shot,
        "run": args.run,
        "time_start": TIME_START,
        "time_end": TIME_END,
        "device": args.device,
    }
else:
    dictionary = {
        "user": args.user,
        "shot": args.shot,
        "run": args.run,
        "device": args.device,
    }
    dictionary["times"] = np.linspace(TIME_START, TIME_END, number_of_samples).tolist()

print("Loading equilibriums from IMAS")
it.loadIMASEquilibriums(dictionary)
print("Done")
paths_to_plot = []
secondary_paths_to_plot = []
x = l2g.plot.Marching()
print("Processing equilibrium")
for index, time, equilibrium in it:
    print(time, flush=True)
    x.setData(equilibrium.grid_r, equilibrium.grid_z, equilibrium.psi)
    # eq = l2g.equil.EQ(equilibrium)
    # eq.evaluate()
    # # Get the contour path
    # paths = x.getContourPath(eq.psiLCFS)
    # paths_to_plot.append(paths[0])
    # if eq.psiLCFS2:
    #     paths = x.getContourPath(eq.psiLCFS2)
    #     print(f"2ndX: {eq.psiLCFS2} {eq.uppXPoint}")
    #     secondary_paths_to_plot.append(paths[0])
    # else:
    #     secondary_paths_to_plot.append([])

    eq = l2g.external.equilibrium_analysis.EQA(equilibrium)
    eq.evaluate()
    paths = x.getContourPath(eq.getBoundaryFluxValue())
    paths_to_plot.append(paths[0])
    plasma_type = eq.getType()
    if plasma_type == "div":
        print(f"2ndX: {eq.getSecondaryXFluxValue()} {eq.getUpperXPoint()}")
        paths = x.getContourPath(eq.getSecondaryXFluxValue())
        secondary_paths_to_plot.append(paths[0])
    else:
        secondary_paths_to_plot.append([])

    times.append(f"t={time:12.4f}s")
print("Done")

# Now make the animation

def update(i, bdry_path, lines, labels):
    while lines:
        el = lines.pop(0)
        el.remove()

    for path in bdry_path[i]:
        lines += ax.plot(path[0], path[1], '-', c='b')

    if secondary_paths_to_plot[i]:
        for path in secondary_paths_to_plot[i]:
            lines += ax.plot(path[0], path[1], '-', c='g')

    # if len(sr[i]):
    #     for j in range(len(sr[i])):
    #         lines += ax.plot(sr[i][j], sz[i][j], '-', c='g')
    ax.set_ylim(Z_LIMITS)
    ax.set_xlim(R_LIMITS)

    lines.append(ax.text(0.7, 0.9, labels[i], transform = ax.transAxes))

lines = [] # Holds plotting objects
frame_update = partial(update, bdry_path=paths_to_plot,
                              lines=lines, labels=times)

anim = FuncAnimation(figure, frame_update, frames=index+1, interval=250)
anim.save(args.output_name, writer=PillowWriter())
