#!/usr/bin/env python3

description = """This script calculates the drsep based on the provided results.
"""

import argparse

parser = argparse.ArgumentParser(description=description,
    formatter_class=argparse.RawTextHelpFormatter)

parser = argparse.ArgumentParser(description=description)
parser.add_argument('-i', '--input_json', type=str,
                    help='Input JSON case file.', required=True)
parser.add_argument('-m', '--input_med', type=str,
                    required=True, help='Input MED file result')

args = parser.parse_args()

import os
import sys
import sys
json_input = args.input_json
if not os.access(json_input, mode=os.R_OK):
    print(f"Could not read: '{json_input}'!")
    sys.exit(-1)

import L2G.utils
import L2G.meshio_utils
import L2G.imas_utils
import imas
import L2G.eq
import L2G.hlm_profiles
import medcoupling as mc
import MEDLoader as ml
from L2G.core import PyEmbreeAccell
import glob
import numpy as np

# Load json file
inp = L2G.utils.load_l2g_json(json_input)

# First check if there is a hlm section
if "hlm" not in inp:
    print(f"No hlm section in {json_input}. Cannot continue")
    sys.exit(-1)

# Obtain information on which exponential function and how Q_par is defined.
function_exp = None
if "function_exp" not in inp["hlm"]:
    print("No defition on which exponential function to use! Check hlm for 'function_exp'")
    sys.exit(-1)
function_exp = inp['hlm']['function_exp']
if function_exp not in ["single", "double", 'ramp_down']:
    print(f"Wrong setting for function_exp: {function_exp}")

function_q_par = None
if "function_q_par" not in inp["hlm"]:
    print("No defition on which exponential function to use! Check hlm for 'function_q_par'")
    # sys.exit(-1)
else:
    function_q_par = inp['hlm']['function_q_par']

    if function_q_par not in ["P_sol", "q_par"]:
        print(f"Wrong setting for function_q_par: {function_q_par}")

    if function_q_par == "P_sol":
        P_sol = inp['hlm']['P_sol']
        F = inp['hlm']['F']
    else:
        Q_parallel = inp['hlm']['q_par']

if 'lambda_q' in inp['hlm']:
    lambda_q = inp['hlm']['lambda_q']
cutoff_conlen = inp['hlm']['cutoff_conlen']

# Obtain the equilibriums
# Figure out what kind of equilibriums do we have
if inp['eq_type'] == "imas":

    import L2G.imas_utils

    shot = inp['imas']['shot']
    run = inp['imas']['run']

    if 'user' not in inp['imas']:
        user = 'public'
    else:
        user = inp['imas']['user']

    if 'device' not in inp['imas']:
        device = 'iter'
    else:
        device = inp['imas']['device']

    if 'version' not in inp['imas']:
        version = '3'
    else:
        version = inp['imas']['version']

    if "times" in inp['imas']:
        time_slices = inp['imas']['times']
    else:
        # Construct the time_slices
        n_steps = int((inp['imas']['time_end'] - inp['imas']['time_start']) / inp['imas']['time_step']) + 1
        time_slices = np.linspace(inp['imas']['time_start'],
                                  inp['imas']['time_end'],
                                  n_steps)
else:
    # In case of EQDSK we might have globs!
    eqdsk_files = []
    for file in inp['eqdsk_files']:
        eqdsk_files += glob.glob(file)

    eqdsk_files.sort()

result_file_name = args.input_med
# Load mesh for creation of fields
result_mesh_data = mc.ReadMeshFromFile(result_file_name)

# First check if there is at least drsep in the fields.
fieldNames = mc.GetAllFieldNames(args.input_med)
if "drsep" not in fieldNames:
    print(f"Field drsep missing in {args.input_med}")
    sys.exit(-1)

# Now obtain all iterations. It is a list of tuples (index, order, time)
field_iterations = ml.GetAllFieldIterations(args.input_med, 'drsep')

N = len(field_iterations)

# If we use IMAS, then open the IDS before the loop. No reason to constantly
# open it over and over
if inp['eq_type'] == 'imas':
    ids = imas.ids(shot, run)
    ids.open_env(user, device, version)
    ids_equilibrium = ids.equilibrium
    # ids_wall is used for retrieving the wall silhouette.
    ids_wall = ids.wall
    ids_wall.get()

for i in range(N):
    print(f"Processing {i+1} of {N} slices.")
    index, order, time = field_iterations[i]
    print(index)

    # Obtain the EQDSK
    if inp['eq_type'] == 'imas':
        # Open the IMAS ids
        ids_equilibrium.getSlice(time, imas.imasdef.INTERPOLATION)
        slice = ids_equilibrium.time_slice[0]
        equilibrium = L2G.eq.getEquilibriumFromIMAS(slice, wall_ids)
    else:
        eqdsk = L2G.eq.EQDSKIO(eqdsk_files[i])
        equilibrium = L2G.eq.getEquilibriumFromEQDSKG(eqdsk)

    # Load the Equilibrium
    # eq = L2G.eq.EQ(eqdsk)
    eq.setEquilibrium(equilibrium)

    # Obtain the midplane boundary values
    eq.evaluate()
    Rb, Z, Btotal, Bpm = eq.getOWL_midplane()

    # Get the fields from the result file
    # Drsep, the distance of each element from the midplane
    drsep = L2G.meshio_utils.fieldToNumpy(args.input_med, "drsep", index) * 1e-3
    # Bdot is the dot product between the normal and the magnetic vector at the
    # element
    Bdot = np.abs(L2G.meshio_utils.fieldToNumpy(args.input_med, 'Bdot', index))
    # BVec is the magnetic vector at the element
    BVec = L2G.meshio_utils.fieldToNumpy(args.input_med, "BVec", index)
    # Poloidal magnetic flux
    flux = L2G.meshio_utils.fieldToNumpy(args.input_med, "flux", index)
    # Connection lengths.
    conlen = L2G.meshio_utils.fieldToNumpy(args.input_med, "conlen", index)

    if function_exp == "single":
        if function_q_par == "P_sol":
            q = L2G.hlm_profiles.single_exponential_psol(drsep, Bpm, Rb, lambda_q, P_sol,
                F)
        else: # q_par
            q = L2G.hlm_profiles.single_exponential_qpar(drsep, Bpm, Rb, lambda_q, q_par)
    elif function_exp == "double": # double
        if function_q_par == "P_sol":
            raise NotImplementedError
        else: # q_par
            raise NotImplementedError
    elif function_exp == "ramp_down":
        # First check if the eqdsk_type is imas. If it is not we cannot gather
        # the necessary
        if inp["eq_type"] != 'imas':
            print('Cannot apply Ramp Down function as key information is ' +
                  'required, which is not available in EQDSK G file.!')
            sys.exit(-1)

        # Obtain information from IMAS equilibrium IDS
        a = slice.boundary.minor_radius
        R = slice.global_quantities.magnetic_axis.r
        Ip = abs(slice.global_quantities.ip) # Also used as P_sol
        Area = slice.global_quantities.area
        if Ip < 10e6:
            # Lambda_q is in millimeters.
            lambda_q = L2G.hlm_profiles.decay_length_L_mode_diverted(a, R,
                Ip, Area)

            print(f'RAMP_DOWN: {i} {time} {lambda_q} {Ip}')
            q = L2G.hlm_profiles.single_exponential_psol(drsep, Bpm, Rb,
                    lambda_q * 1e-3, Ip)
        else:
            lambda_q = 'NaN'
            q = np.zeros(drsep.shape)

    # Now we have our parallel q. We have to apply the total expansion factor!

    # Total flux expansion and incident angle!
    if function_q_par == "P_sol" or function_exp == "ramp_down":
        # In the single_exponential_psol, a B_toroidal (we take total) is
        # missing from the expression, since when we apply the total flux
        # expansion term, it destroys itself.
        q *= Bdot
    else:
        # To take into account the total flux expansion. Though here the ratio
        # between totals at the geometrical element and midplane is taken...
        q *= Bdot / Bt


    # Now apply the cutoff

    q = np.where(conlen > cutoff_conlen, q, 0)

    # Write the result to the file at the correct index.

    # Convert to field
    q_field = L2G.meshio_utils.numpyArrayToField(arr=q,
        fieldName=f"q",
        mesh=result_mesh_data,
        iteration=index, associatedTime=time)
    L2G.meshio_utils.writeFieldToAlreadyExistingMesh(q_field,
        result_file_name)

