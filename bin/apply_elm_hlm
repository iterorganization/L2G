#!/usr/bin/env python3

description = """This script applies the Steady-State heat load profile on a
given L2G result data.
"""

import argparse

parser = argparse.ArgumentParser(description=description,
    formatter_class=argparse.RawTextHelpFormatter)

parser = argparse.ArgumentParser(description=description)
parser.add_argument('-eq', '--input_eqdsk', help='Input EQDSK G format')
parser.add_argument('-m', '--input_med', type=str,
                    required=True, help='Input MED file result')
parser.add_argument('-e', '--input_elm', type=str, default='',
                    help='Input elm file for diverted scenarios (optional)')
parser.add_argument('-c', '--cutoff', type=float, default=4.3e3,
                    help='Input cutoff length of FLs. In millimeters')
parser.add_argument('-rb', '--r_break', type=float, default=0.025,
                    help='Breakpoint. In meters.')

args = parser.parse_args()

import numpy as np
import l2g.equil
import l2g.utils.meshio
import l2g.hlm.steady_state
import medcoupling as mc

print("Applying ELM PLM profile...")

# Load ELM data
elm_data = np.loadtxt(args.input_elm)

result_mesh_data = mc.ReadMeshFromFile(args.input_med)
CUTOFF = args.cutoff
print(f"Cut-off for connection lengths is {CUTOFF*1e-3} m.")
eq = l2g.equil.EQ()
eqdsk = l2g.equil.EQDSKIO(args.input_eqdsk)
equilibrium = l2g.equil.getEquilibriumFromEQDSKG(eqdsk)
eq.setEquilibrium(equilibrium)
eq.evaluate()

drsep = l2g.utils.meshio.fieldToNumpy(args.input_med, "drsep") * 1e-3
Bdot = np.abs(l2g.utils.meshio.fieldToNumpy(args.input_med, 'Bdot'))
BVec = l2g.utils.meshio.fieldToNumpy(args.input_med, "BVec")
flux = l2g.utils.meshio.fieldToNumpy(args.input_med, "flux")
conlen = l2g.utils.meshio.fieldToNumpy(args.input_med, "conlen")
bfield_mag = np.linalg.norm(BVec, axis=1)
Rb, Z, Btotal, Bpm = eq.getOWL_midplane()
# Point to ELM data slice
elm_data_r = elm_data[0]
elm_data_q = elm_data[1] * 1e6

expansion = bfield_mag / Btotal

expansionField = l2g.utils.meshio.numpyArrayToField(expansion,
    "Total flux expansion", result_mesh_data, 0, -1)
l2g.utils.meshio.writeFieldToAlreadyExistingMesh(expansionField,
    args.input_med)

interELM = l2g.hlm.steady_state.inter_ELM(drsep, Rb, Btotal, Bpm, Rb=args.r_break)
elm = l2g.hlm.steady_state.ELM(drsep, elm_data_r, elm_data_q)

elm_par_field = l2g.utils.meshio.numpyArrayToField(elm,
    "Parallel ELM", result_mesh_data, 0, -1)
l2g.utils.meshio.writeFieldToAlreadyExistingMesh(elm_par_field,
    args.input_med)

interElm_par_field = l2g.utils.meshio.numpyArrayToField(interELM,
    "Parallel inter-ELM", result_mesh_data, 0, -1)
l2g.utils.meshio.writeFieldToAlreadyExistingMesh(interElm_par_field,
    args.input_med)

q_parallel = interELM + elm
q_parallel_field = l2g.utils.meshio.numpyArrayToField(q_parallel,
    "Parallel ELM + inter-ELM", result_mesh_data, 0, -1)
l2g.utils.meshio.writeFieldToAlreadyExistingMesh(q_parallel_field,
    args.input_med)

q_inc = (elm + interELM) * Bdot / Btotal # Bdot applies the incident angle and the total
                          # flux expansion
q_inc = np.where(conlen > CUTOFF, q_inc, 0)
q_inc_field = l2g.utils.meshio.numpyArrayToField(q_inc,
    "ELM + inter-ELM", result_mesh_data, 0, -1)
l2g.utils.meshio.writeFieldToAlreadyExistingMesh(q_inc_field,
    args.input_med)

print("Done.")
