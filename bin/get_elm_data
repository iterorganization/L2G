#!/usr/bin/env python3

import argparse

description="""Get ELM PLM profile from input connection length graph.

Arguments:
    input : Path to CSV file containing connection length in dependence of
        drsep.
    nx: Column index for the drsep (X-axis) in the csv file. Default 0
    ny: Column index for the conlen (Y-axis) in the csv file. Default 3.
        The reason for default value 3 is, because the get_owl_conlen_graph
        stores the Owl-Owl or downward connection length graph in the 4 column
        (0 starting index).
    g: Switch to create graphics, namely the ELM PLM plot, which contains the
        connection length graph, power losses, decay length and the q parallel
        of the inter-ELM + ELM contributions (alongside the conservative
        contributions are plotted). Second graphics shows only the q parallels.
    eq: Path to EQDSK G file. This has to be set mandatory if we wish to create
        the graphics, as the drsep information is derived from the equilibrium
        data.

Default arguments:
    fELM = 33 # ELM frequency [Hz]
    WELM0 = 0.6  # Energy lost per ELM [MJ]
    nfil = 10  # number of filaments
    poloWidth = 0.6  # poloidal width of filament [m]
    aveFac = 1.7  # averaging factor
    Aion = 2.5  # 2.5 for DT plasma
    n0 = 0.375  # filament peak density at R=Rsep [10^20 m^-3]
    Te0 = 2500  # filament peak electron temperature at R=Rsep [eV]
    Ti0 = Te0  # filament peak ion temperature at R=Rsep [eV]
    dr = 0  # difference of r from the LCFS
    v_elm = 500  # radial propagation speed [m/s]
    Etot = 0.6e6  # prescribed total energy released per ELM, dWELM [W]
    sigmar = 3e-2  # filament radial width [m]
    sigmaz = 0.45  # filament vertical height [m]
    rg2f = 2  # gap-to-filament ratio
    nfil = 10  # number of ELM filaments
    lambdaW = 0.0213  # approximate radial e-folding length of the ELM
                      # energy (fit for drsep1 = 0-10 cm for the QDN
                      # equilibrium)
"""

parser = argparse.ArgumentParser(description=description,
    formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-i', '--input', type=str, required=True,
    help="Input connection length graph file. Expected file is column csv file, which can be loaded with numpy.load_txt",
    metavar="connection_length_file.txt")
parser.add_argument('-nx', '--drsep_index', type=int, default=0,
    help="Column index for drsep values (x axis)", metavar="N")
parser.add_argument('-ny', '--conlen_index', type=int, default=3,
    help="Column index for connection length", metavar="N")
parser.add_argument('-g', '--create_graphics', type=bool, default=False,
    help="Create additional graphics", metavar="True|False")
parser.add_argument('-eq', '--eqdsk', type=str,
    help="Eqdsk file required for making the graphics", metavar="file.eqdsk")

args = parser.parse_args()

import os
import sys
import numpy as np
from L2G.elm import ELM_loss

fELM = 33 # ELM frequency [Hz]
WELM0 = 0.6  # Energy lost per ELM [MJ]
nfil = 10  # number of filaments
poloWidth = 0.6  # poloidal width of filament [m]
aveFac = 1.7  # averaging factor
Aion = 2.5  # 2.5 for DT plasma
n0 = 0.375  # filament peak density at R=Rsep [10^20 m^-3]
Te0 = 2500  # filament peak electron temperature at R=Rsep [eV]
Ti0 = Te0  # filament peak ion temperature at R=Rsep [eV]
dr = 0  # difference of r from the LCFS
v_elm = 500  # radial propagation speed [m/s]
Etot = 0.6e6  # prescribed total energy released per ELM, dWELM [W]
sigmar = 3e-2  # filament radial width [m]
sigmaz = 0.45  # filament vertical height [m]
rg2f = 2  # gap-to-filament ratio
nfil = 10  # number of ELM filaments
lambdaW = 0.0213  # approximate radial e-folding length of the ELM
                  # energy (fit for drsep1 = 0-10 cm for the QDN
                  # equilibrium)

inputFile = args.input
outputFileName = f"{os.path.splitext(os.path.basename(inputFile))[0]}_elm.txt"
raw_data = np.loadtxt(inputFile)

index_drsep = args.drsep_index
index_conlen = args.conlen_index
r_out = raw_data[:, index_drsep]
r_out[0] = 0 # Set the first drsep to 0 if it isn't...
Lcon_data = raw_data[:, index_conlen]
print(f"Processing {os.path.basename(inputFile)}")
elm_loss = ELM_loss(v_elm, n0, Te0, Ti0, Aion,
                    fELM, nfil, poloWidth, aveFac, Lcon_data, r_out)
[n, Te, Ti, Ee, Ei,
 W, t_out, M] = elm_loss.ELM_loss_profile(v_elm, n0, Te0, Ti0, r_out,
                                          Lcon_data)
print('Finished calculating ELM_loss_profile')
W_harm_med = W

data_jnme = elm_loss.calculate_ELM_profile(W_harm_med,
                                           r_out,
                                           WELM0, fELM,
                                           nfil,
                                           poloWidth,
                                           aveFac, t_out,
                                           v_elm, Etot,
                                           sigmar,
                                           sigmaz,
                                           lambdaW,
                                           npts=len(r_out),
                                           rlim=max(r_out))
print('Finished calculating ELM_profile')


np.savetxt(os.path.join(os.getcwd(), outputFileName), data_jnme[:2])

if args.create_graphics:
    from L2G.eq import EQDSKIO, EQ, getEquilibriumFromEQDSKG
    import matplotlib.pyplot as plt

    eqdsk = EQDSKIO(args.eqdsk)
    if not eqdsk.successfullRead:
        print(f'Failed to read "{args.eqdsk}"')
        print("EQDSK file required, to calculate the midplane parameters for "
              "the inter-ELM profile.")
        sys.exit(1)

    equilibrium = getEquilibriumFromEQDSKG(eqdsk)

    eq = EQ(equilibrium)
    eq.evaluate()
    Rb, Z, Btot, Bpm = eq.getOWL_midplane()

    print("Generating_graphics")
    fig, axs = plt.subplots(1, 4, figsize=(12, 6), tight_layout=True, dpi=100)

    axs[0].set_title('a) $L_{conn}[m]$')
    axs[1].set_title('b) $W_{fil}/W_{0fil}$')
    axs[2].set_title('c) $\lambda [mm]$')  # $[(dW/dr)/W]^{-1}[mm]$
    axs[3].set_title(r'a) $q_{\parallel, ELM} + q_{\parallel, inter-ELM}[\frac{MW}{m^2}]$')

    XLABEL = '$r-r_{sep}[mm]$'

    axs[0].plot(r_out * 1e3, Lcon_data)
    axs[0].grid(True)
    axs[0].set_xlabel(XLABEL)
    axs[0].set_xlim((-2.5, 200.0))

    axs[1].grid(True)
    axs[1].set_xlim((0, 200.0))
    axs[1].set_xlabel(XLABEL)
    axs[1].semilogy(r_out[:-1]*1000, W_harm_med.NORM[:-1], 'b',
                  label='Steady state')

    axs[2].semilogy(np.array(data_jnme[0][:-1]) * 1000,
                    np.array(data_jnme[2]) * 1000, 'b',
                    label='Steady state')
    axs[2].grid(True)
    axs[2].set_xlabel(XLABEL)
    axs[2].set_xlim((-2.5, 200.0))

    def interELM_ICRH(R, Rb, Btot, Bpm, lambda_n=0.005, lambda_m=0.17):
        P_sol = 100 # MW
        F = 0.5
        Rbreak=0.025

        q = np.zeros(R.shape)
        C = F * P_sol * Btot / (2 * np.pi * Rb * Bpm * lambda_n)
        q = np.where(R < Rbreak,
                     C * np.exp(-R/lambda_n),
                     C * np.exp(-R/lambda_m + Rbreak/lambda_m - Rbreak/lambda_n))
        return q

    q_interELM_break = interELM_ICRH(data_jnme[0], Rb, Btot, Bpm)

    axs[3].semilogy(data_jnme[0] * 1000, data_jnme[1] + q_interELM_break, 'b',
                    label='ELM PLM + inter-ELM')
    axs[3].semilogy(data_jnme[0] * 1000, data_jnme[1], 'y--',
                    label='ELM PLM')
    axs[3].semilogy(data_jnme[0] * 1000, q_interELM_break, 'g--',
                    label='inter-ELM')

    axs[3].set_xlim((0, 200.0))
    axs[3].set_ylim((0.001, 1000.0))

    # Steady-State profile
    r = np.linspace(0, 0.3, 500)
    q = 5
    # 8.29 - 8.20
    lambda_q = 0.09

    DRSEP = eq.drsep * 1e-3 # We convert it back to meters
    print(f"Evaluated drsep: {DRSEP}")

    q_elm = q * np.exp(-(r - DRSEP) / 0.09)
    q_inter = 3 * np.exp(-(r - DRSEP) / 0.17)


    axs[3].semilogy(r*1000, q_elm + q_inter, 'k', label='Conservative model')
    # axs[3].semilogy(r*1000 + 90, q_elm, 'k', label='Conservative model')
    # plt.tick_params(axis='y', which='minor')
    # axs[3].yaxis.set_minor_formatter(FormatStrFormatter("%.1f"))
    # axs[3].set_ylabel(r'$q_{\parallel} \frac{MW}{m^2}$'))
    axs[3].set_xlabel(XLABEL)
    axs[3].grid(True, which='both')
    axs[3].vlines(1e3 * DRSEP, ymin=0, ymax=200, colors='r')
    axs[3].text(1e3 * DRSEP, 150, r"$2^{nd} sep$", rotation=90)
    axs[3].legend()

    fig.savefig(f"{os.path.splitext(os.path.basename(inputFile))[0]}.pdf")

    # Now just a figure with the heat loads profiles.

    f = plt.figure()
    ax = f.add_subplot(111)
    ax.semilogy(data_jnme[0] * 1000, data_jnme[1] + q_interELM_break, 'b',
                label='ELM PLM + inter-ELM')
    ax.semilogy(data_jnme[0] * 1000, data_jnme[1], 'y--',
                label='ELM PLM')
    ax.semilogy(data_jnme[0] * 1000, q_interELM_break, 'g--',
                label='inter-ELM')
    ax.semilogy(r*1000, q_elm + q_inter, 'k', label='Conservative model')
    ax.set_xlabel(XLABEL)
    ax.grid(True, which='both')
    ax.vlines(1e3 * DRSEP, ymin=0, ymax=200, colors='r')
    ax.text(1e3 * DRSEP, 150, r"$2^{nd} sep$", rotation=90)
    ax.set_title(r'a) $q_{\parallel, ELM} + q_{\parallel, inter-ELM}[\frac{MW}{m^2}]$')
    ax.legend()
    ax.set_xlim((0, 200.0))
    ax.set_ylim((0.001, 1000.0))

    f.savefig(f"{os.path.splitext(os.path.basename(inputFile))[0]}_qpar.pdf")